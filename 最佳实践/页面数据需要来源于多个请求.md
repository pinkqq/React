## 页面的数据需要来源于多个请求时，如何处理？

页面数据来自多个请求，需要考虑这几点：

- 请求之间无依赖关系，可以并发进行
- 请求之间存在依赖关系，需要依次进行
- 请求完成之前，页面显示 Loading 状态

loading 的状态由当前数据状态决定，并不是一个单独的状态

multiple-request 需求：

- 根据用户信息初始化数据
- 切换 province，加载对应的 cities 列表

## Promise

Promise 对象用于表示一个异步操作的最终完成(或失败)及其结果值。

一个 Promise 必然处于以下几种状态之一：

- 待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。
- 已兑现（fulfilled）: 意味着操作成功完成。
- 已拒绝（rejected）: 意味着操作失败。

链式调用：resolve 函数对应 then；reject 函数对应 catch；

## async/await

async 和 await 关键字让我们可以用一种更简洁的方式写出基于 Promise 的异步行为，而无需刻意地链式调用 promise。

### async 关键字

```js
async function hello() {
  return 'Hello';
}
// let hello = async function() { return "Hello" };
// let hello = async () => {
//   return 'Hello';
// };
hello();
```

调用该函数会返回一个 promise。这是异步函数的特征之一 —— 它保证函数的返回值为 promise。

在函数声明为 async 时，JavaScript 引擎会添加必要的处理，以优化你的程序。

### await 关键字

当 await 关键字与异步函数一起使用时，它的真正优势就变得明显了 —— **事实上， await 只在异步函数里面才起作用。** 它可以放在任何异步的，基于 promise 的函数之前。它会暂停代码在该行上，直到 promise 完成，然后返回结果值。在暂停的同时，其他正在等待执行的代码就有机会执行了。

### 缺陷

Async/await 让你的代码看起来是同步的，在某种程度上，也使得它的行为更加地同步。 await 关键字会阻塞其后的代码，直到 promise 完成，就像执行同步操作一样。它确实可以允许其他任务在此期间继续运行，但您自己的代码被阻塞。

这意味着您的代码可能会因为大量 await 的 promises 相继发生而变慢。每个 await 都会等待前一个完成，而你实际想要的是所有的这些 promises 同时开始处理（就像我们没有使用 async/await 时那样）。

有一种模式可以缓解这个问题——通过将 Promise 对象存储在变量中来同时开始它们，然后等待它们全部执行完毕。让我们看一些证明这个概念的例子。

```js
async function timeTest() {
  await timeoutPromise(3000);
  await timeoutPromise(3000);
  await timeoutPromise(3000);
}
```

总运行时间大约为 9 秒。

```js
async function timeTest() {
  const timeoutPromise1 = timeoutPromise(3000);
  const timeoutPromise2 = timeoutPromise(3000);
  const timeoutPromise3 = timeoutPromise(3000);

  await timeoutPromise1;
  await timeoutPromise2;
  await timeoutPromise3;
}
```

在这里，我们将三个 Promise 对象存储在变量中，这样可以同时启动它们关联的进程。总运行时间仅超过 3 秒！
